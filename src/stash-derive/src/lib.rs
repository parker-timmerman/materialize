// Copyright Materialize, Inc. and contributors. All rights reserved.
//
// Use of this software is governed by the Business Source License
// included in the LICENSE file.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0.

// BEGIN LINT CONFIG
// DO NOT EDIT. Automatically generated by bin/gen-lints.
// Have complaints about the noise? See the note in misc/python/materialize/cli/gen-lints.py first.
#![allow(clippy::style)]
#![allow(clippy::complexity)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::mutable_key_type)]
#![allow(clippy::stable_sort_primitive)]
#![allow(clippy::map_entry)]
#![allow(clippy::box_default)]
#![warn(clippy::bool_comparison)]
#![warn(clippy::clone_on_ref_ptr)]
#![warn(clippy::no_effect)]
#![warn(clippy::unnecessary_unwrap)]
#![warn(clippy::dbg_macro)]
#![warn(clippy::todo)]
#![warn(clippy::wildcard_dependencies)]
#![warn(clippy::zero_prefixed_literal)]
#![warn(clippy::borrowed_box)]
#![warn(clippy::deref_addrof)]
#![warn(clippy::double_must_use)]
#![warn(clippy::double_parens)]
#![warn(clippy::extra_unused_lifetimes)]
#![warn(clippy::needless_borrow)]
#![warn(clippy::needless_question_mark)]
#![warn(clippy::needless_return)]
#![warn(clippy::redundant_pattern)]
#![warn(clippy::redundant_slicing)]
#![warn(clippy::redundant_static_lifetimes)]
#![warn(clippy::single_component_path_imports)]
#![warn(clippy::unnecessary_cast)]
#![warn(clippy::useless_asref)]
#![warn(clippy::useless_conversion)]
#![warn(clippy::builtin_type_shadow)]
#![warn(clippy::duplicate_underscore_argument)]
#![warn(clippy::double_neg)]
#![warn(clippy::unnecessary_mut_passed)]
#![warn(clippy::wildcard_in_or_patterns)]
#![warn(clippy::collapsible_if)]
#![warn(clippy::collapsible_else_if)]
#![warn(clippy::crosspointer_transmute)]
#![warn(clippy::excessive_precision)]
#![warn(clippy::overflow_check_conditional)]
#![warn(clippy::as_conversions)]
#![warn(clippy::match_overlapping_arm)]
#![warn(clippy::zero_divided_by_zero)]
#![warn(clippy::must_use_unit)]
#![warn(clippy::suspicious_assignment_formatting)]
#![warn(clippy::suspicious_else_formatting)]
#![warn(clippy::suspicious_unary_op_formatting)]
#![warn(clippy::mut_mutex_lock)]
#![warn(clippy::print_literal)]
#![warn(clippy::same_item_push)]
#![warn(clippy::useless_format)]
#![warn(clippy::write_literal)]
#![warn(clippy::redundant_closure)]
#![warn(clippy::redundant_closure_call)]
#![warn(clippy::unnecessary_lazy_evaluations)]
#![warn(clippy::partialeq_ne_impl)]
#![warn(clippy::redundant_field_names)]
#![warn(clippy::transmutes_expressible_as_ptr_casts)]
#![warn(clippy::unused_async)]
#![warn(clippy::disallowed_methods)]
#![warn(clippy::disallowed_macros)]
#![warn(clippy::disallowed_types)]
#![warn(clippy::from_over_into)]
// END LINT CONFIG

use proc_macro::TokenStream;
use quote::{format_ident, quote, ToTokens};
use syn::parse::Parse;
use syn::punctuated::Punctuated;
use syn::spanned::Spanned;
use syn::token::Comma;
use syn::{parse_macro_input, Attribute, Fields, GenericArgument, LitInt, PathArguments, Token};
use syn::{Ident, ItemStruct, Type, TypePath};

use mz_stash_version::STASH_VERSION;

mod snapshot;

macro_rules! error {
    ($span:expr, $msg:literal) => {{
        let error = ::quote::quote_spanned! {
            $span => compile_error!($msg);
        };
        TokenStream::from(error)
    }};
}

macro_rules! bail {
    ($span:expr, $msg:literal) => {
        return error!($span, $msg)
    };
}

#[proc_macro_attribute]
pub fn stash_object(attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemStruct);

    let Fields::Named(named_fields) = &input.fields else {
        bail!(input.span(), "You can only derive StashObject on a struct with named fields");
    };

    // For each field in a struct, we parse the attributes we care about, and collect them.
    let mut fields = Vec::new();
    for field in &named_fields.named {
        let attrs_result = FieldAttributes::new(&field.attrs)
            .map_err(|e| proc_macro::TokenStream::from(e.to_compile_error()));
        let attrs = match attrs_result {
            Ok(a) => a,
            Err(tokens) => return tokens,
        };

        fields.push(ObjectField::new(field.clone(), attrs));
    }

    // Get any attributes e.g. "#[derive(Debug)]" for the struct.
    let attrs: proc_macro2::TokenStream = input.attrs.iter().map(|a| a.to_token_stream()).collect();
    // Convert the visibility of the struct to a token stream so we can paste it.
    let vis = input.vis.to_token_stream();

    // Determine the version this struct was introduced.
    let result = syn::parse::<ObjectAttributes>(attr)
        .map_err(|e| proc_macro::TokenStream::from(e.to_compile_error()));
    let struct_attrs = match result {
        Ok(attrs) => attrs,
        Err(e) => return e,
    };
    let initial_version = struct_attrs.introduced.unwrap_or(0);
    let final_version = struct_attrs.removed.unwrap_or(STASH_VERSION);

    // Generate one version of the struct for each version of the Stash.
    let mut structs = Vec::new();
    for v in initial_version..=final_version {
        let name = format_ident!("{}V{}", input.ident, v);
        let fields: proc_macro2::TokenStream = fields
            .iter()
            .filter_map(|f| f.for_version(v))
            .map(|f| {
                quote! { #f, }
            })
            .collect();

        let out = quote! {
            #attrs
            #vis struct #name {
                #fields
            }
        };

        // Make sure each struct matches the snapshot we have persisted, or
        // persist a new snapshot
        let mod_name = input.ident.to_string();
        if let Err(e) = snapshot::snapshot(mod_name.as_str(), v, out.clone()) {
            return TokenStream::from(e);
        }

        structs.push(out);
    }
    // Collect all of the structs together into a single token stream.
    let versions: proc_macro2::TokenStream = structs.into_iter().collect();

    let name = input.ident;
    let latest = format_ident!("{}V{}", name, final_version);

    // Create our final TokenStream, aliasing the latest version of the struct.
    let out = quote! {
        #versions
        #vis type #name = #latest;
    };

    TokenStream::from(out)
}

#[derive(Debug)]
struct ObjectField {
    field: syn::Field,
    stash_attrs: FieldAttributes,
}

impl ObjectField {
    pub fn new(field: syn::Field, stash_attrs: FieldAttributes) -> Self {
        let field = syn::Field {
            attrs: field
                .attrs
                .into_iter()
                .filter(|a| !a.path().is_ident("stash"))
                .collect(),
            vis: field.vis,
            mutability: field.mutability,
            ident: field.ident,
            colon_token: field.colon_token,
            ty: field.ty,
        };

        ObjectField { field, stash_attrs }
    }

    pub fn for_version(&self, version: usize) -> Option<syn::Field> {
        const STD_TYPES: &[&'static str] = &[
            "String", "BTreeMap", "HashMap", "BTreeSet", "HashSet", "u8", "u16", "u32", "u64",
            "u128", "i8", "i16", "i32", "i64", "i128", "f32", "f64", "isize", "usize", "bool",
            "Option", "Result",
        ];

        if self.stash_attrs.exists_in_version(version) {
            let mut field = self.field.clone();

            fn version_type(ty: &mut Type, version: usize) {
                if let Type::Path(TypePath { path, .. }) = ty {
                    if let Some(segment) = path.segments.last_mut() {
                        // Recursively reference the versioned structs in any generics params.
                        if let PathArguments::AngleBracketed(generic_params) =
                            &mut segment.arguments
                        {
                            for arg in &mut generic_params.args {
                                if let GenericArgument::Type(type_arg) = arg {
                                    version_type(type_arg, version)
                                }
                            }
                        }
                        // Don't try to reference versioned structs for types from std.
                        if !STD_TYPES.contains(&&*segment.ident.to_string()) {
                            segment.ident = format_ident!("{}V{version}", segment.ident);
                        }
                    }
                }
            }

            // Recursively update all of the types for this field to be versioned.
            version_type(&mut field.ty, version);

            Some(field)
        } else {
            None
        }
    }
}

#[derive(Debug, Default)]
struct FieldAttributes {
    introduced: Option<usize>,
    removed: Option<usize>,
}

impl FieldAttributes {
    fn new(attrs: &Vec<Attribute>) -> Result<Self, syn::Error> {
        let stash_attrs = attrs.iter().filter(|a| a.path().is_ident("stash"));
        let mut field_attrs = FieldAttributes::default();

        // We support attibutes in the form of "#[stash(ident = value)]" on the fields of a struct.
        for attr in stash_attrs {
            let attr_expr: AttributeExpression = attr.parse_args()?;
            let (kind, version) = attr_expr.parts();

            match kind.as_str() {
                "introduced" => field_attrs.introduced = Some(version),
                "removed" => field_attrs.removed = Some(version),
                // Add more attributes types here!
                _ => {
                    return Err(syn::Error::new(
                        attr.span(),
                        "Unsupported stash attribute identifier",
                    ));
                }
            }
        }

        Ok(field_attrs)
    }

    fn exists_in_version(&self, version: usize) -> bool {
        match (self.introduced, self.removed) {
            (None, None) => true,
            (Some(intro), None) if version >= intro => true,
            (Some(intro), Some(remove)) if version >= intro && version < remove => true,
            (None, Some(remove)) if version < remove => true,
            _ => false,
        }
    }
}

#[derive(Default)]
struct ObjectAttributes {
    introduced: Option<usize>,
    removed: Option<usize>,
}

impl Parse for ObjectAttributes {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let punctuated: Punctuated<AttributeExpression, Comma> =
            Punctuated::parse_terminated(input)?;

        let mut obj_attr = ObjectAttributes::default();
        for (kind, version) in punctuated.into_iter().map(|a| a.parts()) {
            match kind.as_str() {
                "introduced" => obj_attr.introduced = Some(version),
                "removed" => obj_attr.removed = Some(version),
                _ => (),
            }
        }

        Ok(obj_attr)
    }
}

struct AttributeExpression {
    ident: Ident,
    _eq_token: Token![=],
    version: usize,
}

impl Parse for AttributeExpression {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let ident: Ident = input.parse()?;
        let eq_token: Token![=] = input.parse()?;
        let version: LitInt = input.parse()?;
        let version = version.base10_parse()?;

        Ok(AttributeExpression {
            ident,
            _eq_token: eq_token,
            version,
        })
    }
}

impl AttributeExpression {
    fn parts(&self) -> (String, usize) {
        (self.ident.to_string(), self.version)
    }
}
